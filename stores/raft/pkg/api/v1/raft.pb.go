// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/raft.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ReplicaRole int32

const (
	ReplicaRole_UNKNOWN  ReplicaRole = 0
	ReplicaRole_MEMBER   ReplicaRole = 1
	ReplicaRole_OBSERVER ReplicaRole = 2
	ReplicaRole_WITNESS  ReplicaRole = 3
	ReplicaRole_REMOVED  ReplicaRole = 4
)

var ReplicaRole_name = map[int32]string{
	0: "UNKNOWN",
	1: "MEMBER",
	2: "OBSERVER",
	3: "WITNESS",
	4: "REMOVED",
}

var ReplicaRole_value = map[string]int32{
	"UNKNOWN":  0,
	"MEMBER":   1,
	"OBSERVER": 2,
	"WITNESS":  3,
	"REMOVED":  4,
}

func (x ReplicaRole) String() string {
	return proto.EnumName(ReplicaRole_name, int32(x))
}

func (ReplicaRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{0}
}

type ShardConfig struct {
	ShardID  ShardID         `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	Replicas []ReplicaConfig `protobuf:"bytes,2,rep,name=replicas,proto3" json:"replicas"`
	Version  uint64          `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ShardConfig) Reset()         { *m = ShardConfig{} }
func (m *ShardConfig) String() string { return proto.CompactTextString(m) }
func (*ShardConfig) ProtoMessage()    {}
func (*ShardConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{0}
}
func (m *ShardConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardConfig.Merge(m, src)
}
func (m *ShardConfig) XXX_Size() int {
	return m.Size()
}
func (m *ShardConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ShardConfig proto.InternalMessageInfo

func (m *ShardConfig) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardConfig) GetReplicas() []ReplicaConfig {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *ShardConfig) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type ReplicaConfig struct {
	ReplicaID ReplicaID   `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	Host      string      `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Port      int32       `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	Role      ReplicaRole `protobuf:"varint,4,opt,name=role,proto3,enum=atomix.stores.raft.v1.ReplicaRole" json:"role,omitempty"`
}

func (m *ReplicaConfig) Reset()         { *m = ReplicaConfig{} }
func (m *ReplicaConfig) String() string { return proto.CompactTextString(m) }
func (*ReplicaConfig) ProtoMessage()    {}
func (*ReplicaConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{1}
}
func (m *ReplicaConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaConfig.Merge(m, src)
}
func (m *ReplicaConfig) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaConfig proto.InternalMessageInfo

func (m *ReplicaConfig) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *ReplicaConfig) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ReplicaConfig) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ReplicaConfig) GetRole() ReplicaRole {
	if m != nil {
		return m.Role
	}
	return ReplicaRole_UNKNOWN
}

type RaftConfig struct {
	ElectionRTT            uint64 `protobuf:"varint,1,opt,name=election_rtt,json=electionRtt,proto3" json:"election_rtt,omitempty"`
	HeartbeatRTT           uint64 `protobuf:"varint,2,opt,name=heartbeat_rtt,json=heartbeatRtt,proto3" json:"heartbeat_rtt,omitempty"`
	SnapshotEntries        uint64 `protobuf:"varint,3,opt,name=snapshot_entries,json=snapshotEntries,proto3" json:"snapshot_entries,omitempty"`
	CompactionOverhead     uint64 `protobuf:"varint,4,opt,name=compaction_overhead,json=compactionOverhead,proto3" json:"compaction_overhead,omitempty"`
	MaxInMemLogSize        uint64 `protobuf:"varint,5,opt,name=max_in_mem_log_size,json=maxInMemLogSize,proto3" json:"max_in_mem_log_size,omitempty"`
	DisableAutoCompactions bool   `protobuf:"varint,6,opt,name=disable_auto_compactions,json=disableAutoCompactions,proto3" json:"disable_auto_compactions,omitempty"`
	OrderedConfigChange    bool   `protobuf:"varint,7,opt,name=ordered_config_change,json=orderedConfigChange,proto3" json:"ordered_config_change,omitempty"`
}

func (m *RaftConfig) Reset()         { *m = RaftConfig{} }
func (m *RaftConfig) String() string { return proto.CompactTextString(m) }
func (*RaftConfig) ProtoMessage()    {}
func (*RaftConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{2}
}
func (m *RaftConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftConfig.Merge(m, src)
}
func (m *RaftConfig) XXX_Size() int {
	return m.Size()
}
func (m *RaftConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RaftConfig proto.InternalMessageInfo

func (m *RaftConfig) GetElectionRTT() uint64 {
	if m != nil {
		return m.ElectionRTT
	}
	return 0
}

func (m *RaftConfig) GetHeartbeatRTT() uint64 {
	if m != nil {
		return m.HeartbeatRTT
	}
	return 0
}

func (m *RaftConfig) GetSnapshotEntries() uint64 {
	if m != nil {
		return m.SnapshotEntries
	}
	return 0
}

func (m *RaftConfig) GetCompactionOverhead() uint64 {
	if m != nil {
		return m.CompactionOverhead
	}
	return 0
}

func (m *RaftConfig) GetMaxInMemLogSize() uint64 {
	if m != nil {
		return m.MaxInMemLogSize
	}
	return 0
}

func (m *RaftConfig) GetDisableAutoCompactions() bool {
	if m != nil {
		return m.DisableAutoCompactions
	}
	return false
}

func (m *RaftConfig) GetOrderedConfigChange() bool {
	if m != nil {
		return m.OrderedConfigChange
	}
	return false
}

type RaftProposal struct {
	Term        Term        `protobuf:"varint,1,opt,name=term,proto3,casttype=Term" json:"term,omitempty"`
	SequenceNum SequenceNum `protobuf:"varint,2,opt,name=sequence_num,json=sequenceNum,proto3,casttype=SequenceNum" json:"sequence_num,omitempty"`
	Data        []byte      `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RaftProposal) Reset()         { *m = RaftProposal{} }
func (m *RaftProposal) String() string { return proto.CompactTextString(m) }
func (*RaftProposal) ProtoMessage()    {}
func (*RaftProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{3}
}
func (m *RaftProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftProposal.Merge(m, src)
}
func (m *RaftProposal) XXX_Size() int {
	return m.Size()
}
func (m *RaftProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RaftProposal proto.InternalMessageInfo

func (m *RaftProposal) GetTerm() Term {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RaftProposal) GetSequenceNum() SequenceNum {
	if m != nil {
		return m.SequenceNum
	}
	return 0
}

func (m *RaftProposal) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetConfigRequest struct {
	ShardID ShardID `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
}

func (m *GetConfigRequest) Reset()         { *m = GetConfigRequest{} }
func (m *GetConfigRequest) String() string { return proto.CompactTextString(m) }
func (*GetConfigRequest) ProtoMessage()    {}
func (*GetConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{4}
}
func (m *GetConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigRequest.Merge(m, src)
}
func (m *GetConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigRequest proto.InternalMessageInfo

func (m *GetConfigRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

type GetConfigResponse struct {
	Shard ShardConfig `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
}

func (m *GetConfigResponse) Reset()         { *m = GetConfigResponse{} }
func (m *GetConfigResponse) String() string { return proto.CompactTextString(m) }
func (*GetConfigResponse) ProtoMessage()    {}
func (*GetConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{5}
}
func (m *GetConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigResponse.Merge(m, src)
}
func (m *GetConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigResponse proto.InternalMessageInfo

func (m *GetConfigResponse) GetShard() ShardConfig {
	if m != nil {
		return m.Shard
	}
	return ShardConfig{}
}

type BootstrapShardRequest struct {
	ShardID   ShardID         `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	ReplicaID ReplicaID       `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	Replicas  []ReplicaConfig `protobuf:"bytes,3,rep,name=replicas,proto3" json:"replicas"`
	Config    RaftConfig      `protobuf:"bytes,4,opt,name=config,proto3" json:"config"`
}

func (m *BootstrapShardRequest) Reset()         { *m = BootstrapShardRequest{} }
func (m *BootstrapShardRequest) String() string { return proto.CompactTextString(m) }
func (*BootstrapShardRequest) ProtoMessage()    {}
func (*BootstrapShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{6}
}
func (m *BootstrapShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BootstrapShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BootstrapShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BootstrapShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BootstrapShardRequest.Merge(m, src)
}
func (m *BootstrapShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *BootstrapShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BootstrapShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BootstrapShardRequest proto.InternalMessageInfo

func (m *BootstrapShardRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *BootstrapShardRequest) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *BootstrapShardRequest) GetReplicas() []ReplicaConfig {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *BootstrapShardRequest) GetConfig() RaftConfig {
	if m != nil {
		return m.Config
	}
	return RaftConfig{}
}

type BootstrapShardResponse struct {
}

func (m *BootstrapShardResponse) Reset()         { *m = BootstrapShardResponse{} }
func (m *BootstrapShardResponse) String() string { return proto.CompactTextString(m) }
func (*BootstrapShardResponse) ProtoMessage()    {}
func (*BootstrapShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{7}
}
func (m *BootstrapShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BootstrapShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BootstrapShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BootstrapShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BootstrapShardResponse.Merge(m, src)
}
func (m *BootstrapShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *BootstrapShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BootstrapShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BootstrapShardResponse proto.InternalMessageInfo

type AddReplicaRequest struct {
	ShardID ShardID       `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	Replica ReplicaConfig `protobuf:"bytes,2,opt,name=replica,proto3" json:"replica"`
	Version uint64        `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *AddReplicaRequest) Reset()         { *m = AddReplicaRequest{} }
func (m *AddReplicaRequest) String() string { return proto.CompactTextString(m) }
func (*AddReplicaRequest) ProtoMessage()    {}
func (*AddReplicaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{8}
}
func (m *AddReplicaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddReplicaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddReplicaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddReplicaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddReplicaRequest.Merge(m, src)
}
func (m *AddReplicaRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddReplicaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddReplicaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddReplicaRequest proto.InternalMessageInfo

func (m *AddReplicaRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *AddReplicaRequest) GetReplica() ReplicaConfig {
	if m != nil {
		return m.Replica
	}
	return ReplicaConfig{}
}

func (m *AddReplicaRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type AddReplicaResponse struct {
}

func (m *AddReplicaResponse) Reset()         { *m = AddReplicaResponse{} }
func (m *AddReplicaResponse) String() string { return proto.CompactTextString(m) }
func (*AddReplicaResponse) ProtoMessage()    {}
func (*AddReplicaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{9}
}
func (m *AddReplicaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddReplicaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddReplicaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddReplicaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddReplicaResponse.Merge(m, src)
}
func (m *AddReplicaResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddReplicaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddReplicaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddReplicaResponse proto.InternalMessageInfo

type RemoveReplicaRequest struct {
	ShardID   ShardID   `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	ReplicaID ReplicaID `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	Version   uint64    `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *RemoveReplicaRequest) Reset()         { *m = RemoveReplicaRequest{} }
func (m *RemoveReplicaRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveReplicaRequest) ProtoMessage()    {}
func (*RemoveReplicaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{10}
}
func (m *RemoveReplicaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveReplicaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveReplicaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveReplicaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveReplicaRequest.Merge(m, src)
}
func (m *RemoveReplicaRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveReplicaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveReplicaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveReplicaRequest proto.InternalMessageInfo

func (m *RemoveReplicaRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *RemoveReplicaRequest) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *RemoveReplicaRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type RemoveReplicaResponse struct {
}

func (m *RemoveReplicaResponse) Reset()         { *m = RemoveReplicaResponse{} }
func (m *RemoveReplicaResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveReplicaResponse) ProtoMessage()    {}
func (*RemoveReplicaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{11}
}
func (m *RemoveReplicaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveReplicaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveReplicaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveReplicaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveReplicaResponse.Merge(m, src)
}
func (m *RemoveReplicaResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveReplicaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveReplicaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveReplicaResponse proto.InternalMessageInfo

type JoinShardRequest struct {
	ShardID   ShardID    `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	ReplicaID ReplicaID  `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	Config    RaftConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config"`
}

func (m *JoinShardRequest) Reset()         { *m = JoinShardRequest{} }
func (m *JoinShardRequest) String() string { return proto.CompactTextString(m) }
func (*JoinShardRequest) ProtoMessage()    {}
func (*JoinShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{12}
}
func (m *JoinShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinShardRequest.Merge(m, src)
}
func (m *JoinShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *JoinShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JoinShardRequest proto.InternalMessageInfo

func (m *JoinShardRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *JoinShardRequest) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *JoinShardRequest) GetConfig() RaftConfig {
	if m != nil {
		return m.Config
	}
	return RaftConfig{}
}

type JoinShardResponse struct {
}

func (m *JoinShardResponse) Reset()         { *m = JoinShardResponse{} }
func (m *JoinShardResponse) String() string { return proto.CompactTextString(m) }
func (*JoinShardResponse) ProtoMessage()    {}
func (*JoinShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{13}
}
func (m *JoinShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinShardResponse.Merge(m, src)
}
func (m *JoinShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *JoinShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JoinShardResponse proto.InternalMessageInfo

type LeaveShardRequest struct {
	ShardID ShardID `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
}

func (m *LeaveShardRequest) Reset()         { *m = LeaveShardRequest{} }
func (m *LeaveShardRequest) String() string { return proto.CompactTextString(m) }
func (*LeaveShardRequest) ProtoMessage()    {}
func (*LeaveShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{14}
}
func (m *LeaveShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaveShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaveShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaveShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaveShardRequest.Merge(m, src)
}
func (m *LeaveShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaveShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaveShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaveShardRequest proto.InternalMessageInfo

func (m *LeaveShardRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

type LeaveShardResponse struct {
}

func (m *LeaveShardResponse) Reset()         { *m = LeaveShardResponse{} }
func (m *LeaveShardResponse) String() string { return proto.CompactTextString(m) }
func (*LeaveShardResponse) ProtoMessage()    {}
func (*LeaveShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{15}
}
func (m *LeaveShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaveShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaveShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaveShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaveShardResponse.Merge(m, src)
}
func (m *LeaveShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaveShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaveShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaveShardResponse proto.InternalMessageInfo

type DeleteDataRequest struct {
	ShardID   ShardID   `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	ReplicaID ReplicaID `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
}

func (m *DeleteDataRequest) Reset()         { *m = DeleteDataRequest{} }
func (m *DeleteDataRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteDataRequest) ProtoMessage()    {}
func (*DeleteDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{16}
}
func (m *DeleteDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDataRequest.Merge(m, src)
}
func (m *DeleteDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDataRequest proto.InternalMessageInfo

func (m *DeleteDataRequest) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *DeleteDataRequest) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

type DeleteDataResponse struct {
}

func (m *DeleteDataResponse) Reset()         { *m = DeleteDataResponse{} }
func (m *DeleteDataResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteDataResponse) ProtoMessage()    {}
func (*DeleteDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{17}
}
func (m *DeleteDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDataResponse.Merge(m, src)
}
func (m *DeleteDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDataResponse proto.InternalMessageInfo

type WatchRequest struct {
}

func (m *WatchRequest) Reset()         { *m = WatchRequest{} }
func (m *WatchRequest) String() string { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()    {}
func (*WatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{18}
}
func (m *WatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchRequest.Merge(m, src)
}
func (m *WatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *WatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WatchRequest proto.InternalMessageInfo

type Event struct {
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Types that are valid to be assigned to Event:
	//	*Event_ReplicaReady
	//	*Event_LeaderUpdated
	//	*Event_ConfigurationChanged
	//	*Event_SendSnapshotStarted
	//	*Event_SendSnapshotCompleted
	//	*Event_SendSnapshotAborted
	//	*Event_SnapshotReceived
	//	*Event_SnapshotRecovered
	//	*Event_SnapshotCreated
	//	*Event_SnapshotCompacted
	//	*Event_LogCompacted
	//	*Event_LogdbCompacted
	//	*Event_ConnectionEstablished
	//	*Event_ConnectionFailed
	Event isEvent_Event `protobuf_oneof:"event"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{19}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

type isEvent_Event interface {
	isEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Event_ReplicaReady struct {
	ReplicaReady *ReplicaReadyEvent `protobuf:"bytes,2,opt,name=replica_ready,json=replicaReady,proto3,oneof" json:"replica_ready,omitempty"`
}
type Event_LeaderUpdated struct {
	LeaderUpdated *LeaderUpdatedEvent `protobuf:"bytes,3,opt,name=leader_updated,json=leaderUpdated,proto3,oneof" json:"leader_updated,omitempty"`
}
type Event_ConfigurationChanged struct {
	ConfigurationChanged *ConfigurationChangedEvent `protobuf:"bytes,4,opt,name=configuration_changed,json=configurationChanged,proto3,oneof" json:"configuration_changed,omitempty"`
}
type Event_SendSnapshotStarted struct {
	SendSnapshotStarted *SendSnapshotStartedEvent `protobuf:"bytes,5,opt,name=send_snapshot_started,json=sendSnapshotStarted,proto3,oneof" json:"send_snapshot_started,omitempty"`
}
type Event_SendSnapshotCompleted struct {
	SendSnapshotCompleted *SendSnapshotCompletedEvent `protobuf:"bytes,6,opt,name=send_snapshot_completed,json=sendSnapshotCompleted,proto3,oneof" json:"send_snapshot_completed,omitempty"`
}
type Event_SendSnapshotAborted struct {
	SendSnapshotAborted *SendSnapshotAbortedEvent `protobuf:"bytes,7,opt,name=send_snapshot_aborted,json=sendSnapshotAborted,proto3,oneof" json:"send_snapshot_aborted,omitempty"`
}
type Event_SnapshotReceived struct {
	SnapshotReceived *SnapshotReceivedEvent `protobuf:"bytes,8,opt,name=snapshot_received,json=snapshotReceived,proto3,oneof" json:"snapshot_received,omitempty"`
}
type Event_SnapshotRecovered struct {
	SnapshotRecovered *SnapshotRecoveredEvent `protobuf:"bytes,9,opt,name=snapshot_recovered,json=snapshotRecovered,proto3,oneof" json:"snapshot_recovered,omitempty"`
}
type Event_SnapshotCreated struct {
	SnapshotCreated *SnapshotCreatedEvent `protobuf:"bytes,10,opt,name=snapshot_created,json=snapshotCreated,proto3,oneof" json:"snapshot_created,omitempty"`
}
type Event_SnapshotCompacted struct {
	SnapshotCompacted *SnapshotCompactedEvent `protobuf:"bytes,11,opt,name=snapshot_compacted,json=snapshotCompacted,proto3,oneof" json:"snapshot_compacted,omitempty"`
}
type Event_LogCompacted struct {
	LogCompacted *LogCompactedEvent `protobuf:"bytes,12,opt,name=log_compacted,json=logCompacted,proto3,oneof" json:"log_compacted,omitempty"`
}
type Event_LogdbCompacted struct {
	LogdbCompacted *LogDBCompactedEvent `protobuf:"bytes,13,opt,name=logdb_compacted,json=logdbCompacted,proto3,oneof" json:"logdb_compacted,omitempty"`
}
type Event_ConnectionEstablished struct {
	ConnectionEstablished *ConnectionEstablishedEvent `protobuf:"bytes,14,opt,name=connection_established,json=connectionEstablished,proto3,oneof" json:"connection_established,omitempty"`
}
type Event_ConnectionFailed struct {
	ConnectionFailed *ConnectionFailedEvent `protobuf:"bytes,15,opt,name=connection_failed,json=connectionFailed,proto3,oneof" json:"connection_failed,omitempty"`
}

func (*Event_ReplicaReady) isEvent_Event()          {}
func (*Event_LeaderUpdated) isEvent_Event()         {}
func (*Event_ConfigurationChanged) isEvent_Event()  {}
func (*Event_SendSnapshotStarted) isEvent_Event()   {}
func (*Event_SendSnapshotCompleted) isEvent_Event() {}
func (*Event_SendSnapshotAborted) isEvent_Event()   {}
func (*Event_SnapshotReceived) isEvent_Event()      {}
func (*Event_SnapshotRecovered) isEvent_Event()     {}
func (*Event_SnapshotCreated) isEvent_Event()       {}
func (*Event_SnapshotCompacted) isEvent_Event()     {}
func (*Event_LogCompacted) isEvent_Event()          {}
func (*Event_LogdbCompacted) isEvent_Event()        {}
func (*Event_ConnectionEstablished) isEvent_Event() {}
func (*Event_ConnectionFailed) isEvent_Event()      {}

func (m *Event) GetEvent() isEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Event) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *Event) GetReplicaReady() *ReplicaReadyEvent {
	if x, ok := m.GetEvent().(*Event_ReplicaReady); ok {
		return x.ReplicaReady
	}
	return nil
}

func (m *Event) GetLeaderUpdated() *LeaderUpdatedEvent {
	if x, ok := m.GetEvent().(*Event_LeaderUpdated); ok {
		return x.LeaderUpdated
	}
	return nil
}

func (m *Event) GetConfigurationChanged() *ConfigurationChangedEvent {
	if x, ok := m.GetEvent().(*Event_ConfigurationChanged); ok {
		return x.ConfigurationChanged
	}
	return nil
}

func (m *Event) GetSendSnapshotStarted() *SendSnapshotStartedEvent {
	if x, ok := m.GetEvent().(*Event_SendSnapshotStarted); ok {
		return x.SendSnapshotStarted
	}
	return nil
}

func (m *Event) GetSendSnapshotCompleted() *SendSnapshotCompletedEvent {
	if x, ok := m.GetEvent().(*Event_SendSnapshotCompleted); ok {
		return x.SendSnapshotCompleted
	}
	return nil
}

func (m *Event) GetSendSnapshotAborted() *SendSnapshotAbortedEvent {
	if x, ok := m.GetEvent().(*Event_SendSnapshotAborted); ok {
		return x.SendSnapshotAborted
	}
	return nil
}

func (m *Event) GetSnapshotReceived() *SnapshotReceivedEvent {
	if x, ok := m.GetEvent().(*Event_SnapshotReceived); ok {
		return x.SnapshotReceived
	}
	return nil
}

func (m *Event) GetSnapshotRecovered() *SnapshotRecoveredEvent {
	if x, ok := m.GetEvent().(*Event_SnapshotRecovered); ok {
		return x.SnapshotRecovered
	}
	return nil
}

func (m *Event) GetSnapshotCreated() *SnapshotCreatedEvent {
	if x, ok := m.GetEvent().(*Event_SnapshotCreated); ok {
		return x.SnapshotCreated
	}
	return nil
}

func (m *Event) GetSnapshotCompacted() *SnapshotCompactedEvent {
	if x, ok := m.GetEvent().(*Event_SnapshotCompacted); ok {
		return x.SnapshotCompacted
	}
	return nil
}

func (m *Event) GetLogCompacted() *LogCompactedEvent {
	if x, ok := m.GetEvent().(*Event_LogCompacted); ok {
		return x.LogCompacted
	}
	return nil
}

func (m *Event) GetLogdbCompacted() *LogDBCompactedEvent {
	if x, ok := m.GetEvent().(*Event_LogdbCompacted); ok {
		return x.LogdbCompacted
	}
	return nil
}

func (m *Event) GetConnectionEstablished() *ConnectionEstablishedEvent {
	if x, ok := m.GetEvent().(*Event_ConnectionEstablished); ok {
		return x.ConnectionEstablished
	}
	return nil
}

func (m *Event) GetConnectionFailed() *ConnectionFailedEvent {
	if x, ok := m.GetEvent().(*Event_ConnectionFailed); ok {
		return x.ConnectionFailed
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Event) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Event_ReplicaReady)(nil),
		(*Event_LeaderUpdated)(nil),
		(*Event_ConfigurationChanged)(nil),
		(*Event_SendSnapshotStarted)(nil),
		(*Event_SendSnapshotCompleted)(nil),
		(*Event_SendSnapshotAborted)(nil),
		(*Event_SnapshotReceived)(nil),
		(*Event_SnapshotRecovered)(nil),
		(*Event_SnapshotCreated)(nil),
		(*Event_SnapshotCompacted)(nil),
		(*Event_LogCompacted)(nil),
		(*Event_LogdbCompacted)(nil),
		(*Event_ConnectionEstablished)(nil),
		(*Event_ConnectionFailed)(nil),
	}
}

type ConnectionInfo struct {
	Address  string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Snapshot bool   `protobuf:"varint,2,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *ConnectionInfo) Reset()         { *m = ConnectionInfo{} }
func (m *ConnectionInfo) String() string { return proto.CompactTextString(m) }
func (*ConnectionInfo) ProtoMessage()    {}
func (*ConnectionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{20}
}
func (m *ConnectionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionInfo.Merge(m, src)
}
func (m *ConnectionInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionInfo proto.InternalMessageInfo

func (m *ConnectionInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ConnectionInfo) GetSnapshot() bool {
	if m != nil {
		return m.Snapshot
	}
	return false
}

type ReplicaEvent struct {
	ShardID   ShardID   `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3,casttype=ShardID" json:"shard_id,omitempty"`
	ReplicaID ReplicaID `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
}

func (m *ReplicaEvent) Reset()         { *m = ReplicaEvent{} }
func (m *ReplicaEvent) String() string { return proto.CompactTextString(m) }
func (*ReplicaEvent) ProtoMessage()    {}
func (*ReplicaEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{21}
}
func (m *ReplicaEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaEvent.Merge(m, src)
}
func (m *ReplicaEvent) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaEvent proto.InternalMessageInfo

func (m *ReplicaEvent) GetShardID() ShardID {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ReplicaEvent) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

type ReplicaReadyEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
}

func (m *ReplicaReadyEvent) Reset()         { *m = ReplicaReadyEvent{} }
func (m *ReplicaReadyEvent) String() string { return proto.CompactTextString(m) }
func (*ReplicaReadyEvent) ProtoMessage()    {}
func (*ReplicaReadyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{22}
}
func (m *ReplicaReadyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaReadyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaReadyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaReadyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaReadyEvent.Merge(m, src)
}
func (m *ReplicaReadyEvent) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaReadyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaReadyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaReadyEvent proto.InternalMessageInfo

type ConfigurationChangedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
}

func (m *ConfigurationChangedEvent) Reset()         { *m = ConfigurationChangedEvent{} }
func (m *ConfigurationChangedEvent) String() string { return proto.CompactTextString(m) }
func (*ConfigurationChangedEvent) ProtoMessage()    {}
func (*ConfigurationChangedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{23}
}
func (m *ConfigurationChangedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigurationChangedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigurationChangedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigurationChangedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationChangedEvent.Merge(m, src)
}
func (m *ConfigurationChangedEvent) XXX_Size() int {
	return m.Size()
}
func (m *ConfigurationChangedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationChangedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationChangedEvent proto.InternalMessageInfo

type LeaderUpdatedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Term         Term      `protobuf:"varint,2,opt,name=term,proto3,casttype=Term" json:"term,omitempty"`
	Leader       ReplicaID `protobuf:"varint,3,opt,name=leader,proto3,casttype=ReplicaID" json:"leader,omitempty"`
}

func (m *LeaderUpdatedEvent) Reset()         { *m = LeaderUpdatedEvent{} }
func (m *LeaderUpdatedEvent) String() string { return proto.CompactTextString(m) }
func (*LeaderUpdatedEvent) ProtoMessage()    {}
func (*LeaderUpdatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{24}
}
func (m *LeaderUpdatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderUpdatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderUpdatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderUpdatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderUpdatedEvent.Merge(m, src)
}
func (m *LeaderUpdatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *LeaderUpdatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderUpdatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderUpdatedEvent proto.InternalMessageInfo

func (m *LeaderUpdatedEvent) GetTerm() Term {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *LeaderUpdatedEvent) GetLeader() ReplicaID {
	if m != nil {
		return m.Leader
	}
	return 0
}

type SendSnapshotStartedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index     `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	To           ReplicaID `protobuf:"varint,3,opt,name=to,proto3,casttype=ReplicaID" json:"to,omitempty"`
}

func (m *SendSnapshotStartedEvent) Reset()         { *m = SendSnapshotStartedEvent{} }
func (m *SendSnapshotStartedEvent) String() string { return proto.CompactTextString(m) }
func (*SendSnapshotStartedEvent) ProtoMessage()    {}
func (*SendSnapshotStartedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{25}
}
func (m *SendSnapshotStartedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSnapshotStartedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSnapshotStartedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendSnapshotStartedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSnapshotStartedEvent.Merge(m, src)
}
func (m *SendSnapshotStartedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendSnapshotStartedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSnapshotStartedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendSnapshotStartedEvent proto.InternalMessageInfo

func (m *SendSnapshotStartedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SendSnapshotStartedEvent) GetTo() ReplicaID {
	if m != nil {
		return m.To
	}
	return 0
}

type SendSnapshotCompletedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index     `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	To           ReplicaID `protobuf:"varint,3,opt,name=to,proto3,casttype=ReplicaID" json:"to,omitempty"`
}

func (m *SendSnapshotCompletedEvent) Reset()         { *m = SendSnapshotCompletedEvent{} }
func (m *SendSnapshotCompletedEvent) String() string { return proto.CompactTextString(m) }
func (*SendSnapshotCompletedEvent) ProtoMessage()    {}
func (*SendSnapshotCompletedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{26}
}
func (m *SendSnapshotCompletedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSnapshotCompletedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSnapshotCompletedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendSnapshotCompletedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSnapshotCompletedEvent.Merge(m, src)
}
func (m *SendSnapshotCompletedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendSnapshotCompletedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSnapshotCompletedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendSnapshotCompletedEvent proto.InternalMessageInfo

func (m *SendSnapshotCompletedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SendSnapshotCompletedEvent) GetTo() ReplicaID {
	if m != nil {
		return m.To
	}
	return 0
}

type SendSnapshotAbortedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index     `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	To           ReplicaID `protobuf:"varint,3,opt,name=to,proto3,casttype=ReplicaID" json:"to,omitempty"`
}

func (m *SendSnapshotAbortedEvent) Reset()         { *m = SendSnapshotAbortedEvent{} }
func (m *SendSnapshotAbortedEvent) String() string { return proto.CompactTextString(m) }
func (*SendSnapshotAbortedEvent) ProtoMessage()    {}
func (*SendSnapshotAbortedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{27}
}
func (m *SendSnapshotAbortedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSnapshotAbortedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSnapshotAbortedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendSnapshotAbortedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSnapshotAbortedEvent.Merge(m, src)
}
func (m *SendSnapshotAbortedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendSnapshotAbortedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSnapshotAbortedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendSnapshotAbortedEvent proto.InternalMessageInfo

func (m *SendSnapshotAbortedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SendSnapshotAbortedEvent) GetTo() ReplicaID {
	if m != nil {
		return m.To
	}
	return 0
}

type SnapshotReceivedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index     `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
	From         ReplicaID `protobuf:"varint,3,opt,name=from,proto3,casttype=ReplicaID" json:"from,omitempty"`
}

func (m *SnapshotReceivedEvent) Reset()         { *m = SnapshotReceivedEvent{} }
func (m *SnapshotReceivedEvent) String() string { return proto.CompactTextString(m) }
func (*SnapshotReceivedEvent) ProtoMessage()    {}
func (*SnapshotReceivedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{28}
}
func (m *SnapshotReceivedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotReceivedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotReceivedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotReceivedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotReceivedEvent.Merge(m, src)
}
func (m *SnapshotReceivedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotReceivedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotReceivedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotReceivedEvent proto.InternalMessageInfo

func (m *SnapshotReceivedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SnapshotReceivedEvent) GetFrom() ReplicaID {
	if m != nil {
		return m.From
	}
	return 0
}

type SnapshotRecoveredEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
}

func (m *SnapshotRecoveredEvent) Reset()         { *m = SnapshotRecoveredEvent{} }
func (m *SnapshotRecoveredEvent) String() string { return proto.CompactTextString(m) }
func (*SnapshotRecoveredEvent) ProtoMessage()    {}
func (*SnapshotRecoveredEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{29}
}
func (m *SnapshotRecoveredEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotRecoveredEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotRecoveredEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotRecoveredEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotRecoveredEvent.Merge(m, src)
}
func (m *SnapshotRecoveredEvent) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotRecoveredEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotRecoveredEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotRecoveredEvent proto.InternalMessageInfo

func (m *SnapshotRecoveredEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type SnapshotCreatedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
}

func (m *SnapshotCreatedEvent) Reset()         { *m = SnapshotCreatedEvent{} }
func (m *SnapshotCreatedEvent) String() string { return proto.CompactTextString(m) }
func (*SnapshotCreatedEvent) ProtoMessage()    {}
func (*SnapshotCreatedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{30}
}
func (m *SnapshotCreatedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotCreatedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotCreatedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotCreatedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotCreatedEvent.Merge(m, src)
}
func (m *SnapshotCreatedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotCreatedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotCreatedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotCreatedEvent proto.InternalMessageInfo

func (m *SnapshotCreatedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type SnapshotCompactedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
}

func (m *SnapshotCompactedEvent) Reset()         { *m = SnapshotCompactedEvent{} }
func (m *SnapshotCompactedEvent) String() string { return proto.CompactTextString(m) }
func (*SnapshotCompactedEvent) ProtoMessage()    {}
func (*SnapshotCompactedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{31}
}
func (m *SnapshotCompactedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotCompactedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotCompactedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotCompactedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotCompactedEvent.Merge(m, src)
}
func (m *SnapshotCompactedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotCompactedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotCompactedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotCompactedEvent proto.InternalMessageInfo

func (m *SnapshotCompactedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type LogEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
}

func (m *LogEvent) Reset()         { *m = LogEvent{} }
func (m *LogEvent) String() string { return proto.CompactTextString(m) }
func (*LogEvent) ProtoMessage()    {}
func (*LogEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{32}
}
func (m *LogEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEvent.Merge(m, src)
}
func (m *LogEvent) XXX_Size() int {
	return m.Size()
}
func (m *LogEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LogEvent proto.InternalMessageInfo

func (m *LogEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type LogCompactedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
}

func (m *LogCompactedEvent) Reset()         { *m = LogCompactedEvent{} }
func (m *LogCompactedEvent) String() string { return proto.CompactTextString(m) }
func (*LogCompactedEvent) ProtoMessage()    {}
func (*LogCompactedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{33}
}
func (m *LogCompactedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogCompactedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogCompactedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogCompactedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogCompactedEvent.Merge(m, src)
}
func (m *LogCompactedEvent) XXX_Size() int {
	return m.Size()
}
func (m *LogCompactedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LogCompactedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LogCompactedEvent proto.InternalMessageInfo

func (m *LogCompactedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type LogDBCompactedEvent struct {
	ReplicaEvent `protobuf:"bytes,1,opt,name=replica,proto3,embedded=replica" json:"replica"`
	Index        Index `protobuf:"varint,2,opt,name=index,proto3,casttype=Index" json:"index,omitempty"`
}

func (m *LogDBCompactedEvent) Reset()         { *m = LogDBCompactedEvent{} }
func (m *LogDBCompactedEvent) String() string { return proto.CompactTextString(m) }
func (*LogDBCompactedEvent) ProtoMessage()    {}
func (*LogDBCompactedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{34}
}
func (m *LogDBCompactedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogDBCompactedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogDBCompactedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogDBCompactedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogDBCompactedEvent.Merge(m, src)
}
func (m *LogDBCompactedEvent) XXX_Size() int {
	return m.Size()
}
func (m *LogDBCompactedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_LogDBCompactedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_LogDBCompactedEvent proto.InternalMessageInfo

func (m *LogDBCompactedEvent) GetIndex() Index {
	if m != nil {
		return m.Index
	}
	return 0
}

type ConnectionEstablishedEvent struct {
	ConnectionInfo `protobuf:"bytes,1,opt,name=info,proto3,embedded=info" json:"info"`
}

func (m *ConnectionEstablishedEvent) Reset()         { *m = ConnectionEstablishedEvent{} }
func (m *ConnectionEstablishedEvent) String() string { return proto.CompactTextString(m) }
func (*ConnectionEstablishedEvent) ProtoMessage()    {}
func (*ConnectionEstablishedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{35}
}
func (m *ConnectionEstablishedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionEstablishedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionEstablishedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionEstablishedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionEstablishedEvent.Merge(m, src)
}
func (m *ConnectionEstablishedEvent) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionEstablishedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionEstablishedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionEstablishedEvent proto.InternalMessageInfo

type ConnectionFailedEvent struct {
	ConnectionInfo `protobuf:"bytes,1,opt,name=info,proto3,embedded=info" json:"info"`
}

func (m *ConnectionFailedEvent) Reset()         { *m = ConnectionFailedEvent{} }
func (m *ConnectionFailedEvent) String() string { return proto.CompactTextString(m) }
func (*ConnectionFailedEvent) ProtoMessage()    {}
func (*ConnectionFailedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_078208a31684120b, []int{36}
}
func (m *ConnectionFailedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionFailedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionFailedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionFailedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionFailedEvent.Merge(m, src)
}
func (m *ConnectionFailedEvent) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionFailedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionFailedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionFailedEvent proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("atomix.stores.raft.v1.ReplicaRole", ReplicaRole_name, ReplicaRole_value)
	proto.RegisterType((*ShardConfig)(nil), "atomix.stores.raft.v1.ShardConfig")
	proto.RegisterType((*ReplicaConfig)(nil), "atomix.stores.raft.v1.ReplicaConfig")
	proto.RegisterType((*RaftConfig)(nil), "atomix.stores.raft.v1.RaftConfig")
	proto.RegisterType((*RaftProposal)(nil), "atomix.stores.raft.v1.RaftProposal")
	proto.RegisterType((*GetConfigRequest)(nil), "atomix.stores.raft.v1.GetConfigRequest")
	proto.RegisterType((*GetConfigResponse)(nil), "atomix.stores.raft.v1.GetConfigResponse")
	proto.RegisterType((*BootstrapShardRequest)(nil), "atomix.stores.raft.v1.BootstrapShardRequest")
	proto.RegisterType((*BootstrapShardResponse)(nil), "atomix.stores.raft.v1.BootstrapShardResponse")
	proto.RegisterType((*AddReplicaRequest)(nil), "atomix.stores.raft.v1.AddReplicaRequest")
	proto.RegisterType((*AddReplicaResponse)(nil), "atomix.stores.raft.v1.AddReplicaResponse")
	proto.RegisterType((*RemoveReplicaRequest)(nil), "atomix.stores.raft.v1.RemoveReplicaRequest")
	proto.RegisterType((*RemoveReplicaResponse)(nil), "atomix.stores.raft.v1.RemoveReplicaResponse")
	proto.RegisterType((*JoinShardRequest)(nil), "atomix.stores.raft.v1.JoinShardRequest")
	proto.RegisterType((*JoinShardResponse)(nil), "atomix.stores.raft.v1.JoinShardResponse")
	proto.RegisterType((*LeaveShardRequest)(nil), "atomix.stores.raft.v1.LeaveShardRequest")
	proto.RegisterType((*LeaveShardResponse)(nil), "atomix.stores.raft.v1.LeaveShardResponse")
	proto.RegisterType((*DeleteDataRequest)(nil), "atomix.stores.raft.v1.DeleteDataRequest")
	proto.RegisterType((*DeleteDataResponse)(nil), "atomix.stores.raft.v1.DeleteDataResponse")
	proto.RegisterType((*WatchRequest)(nil), "atomix.stores.raft.v1.WatchRequest")
	proto.RegisterType((*Event)(nil), "atomix.stores.raft.v1.Event")
	proto.RegisterType((*ConnectionInfo)(nil), "atomix.stores.raft.v1.ConnectionInfo")
	proto.RegisterType((*ReplicaEvent)(nil), "atomix.stores.raft.v1.ReplicaEvent")
	proto.RegisterType((*ReplicaReadyEvent)(nil), "atomix.stores.raft.v1.ReplicaReadyEvent")
	proto.RegisterType((*ConfigurationChangedEvent)(nil), "atomix.stores.raft.v1.ConfigurationChangedEvent")
	proto.RegisterType((*LeaderUpdatedEvent)(nil), "atomix.stores.raft.v1.LeaderUpdatedEvent")
	proto.RegisterType((*SendSnapshotStartedEvent)(nil), "atomix.stores.raft.v1.SendSnapshotStartedEvent")
	proto.RegisterType((*SendSnapshotCompletedEvent)(nil), "atomix.stores.raft.v1.SendSnapshotCompletedEvent")
	proto.RegisterType((*SendSnapshotAbortedEvent)(nil), "atomix.stores.raft.v1.SendSnapshotAbortedEvent")
	proto.RegisterType((*SnapshotReceivedEvent)(nil), "atomix.stores.raft.v1.SnapshotReceivedEvent")
	proto.RegisterType((*SnapshotRecoveredEvent)(nil), "atomix.stores.raft.v1.SnapshotRecoveredEvent")
	proto.RegisterType((*SnapshotCreatedEvent)(nil), "atomix.stores.raft.v1.SnapshotCreatedEvent")
	proto.RegisterType((*SnapshotCompactedEvent)(nil), "atomix.stores.raft.v1.SnapshotCompactedEvent")
	proto.RegisterType((*LogEvent)(nil), "atomix.stores.raft.v1.LogEvent")
	proto.RegisterType((*LogCompactedEvent)(nil), "atomix.stores.raft.v1.LogCompactedEvent")
	proto.RegisterType((*LogDBCompactedEvent)(nil), "atomix.stores.raft.v1.LogDBCompactedEvent")
	proto.RegisterType((*ConnectionEstablishedEvent)(nil), "atomix.stores.raft.v1.ConnectionEstablishedEvent")
	proto.RegisterType((*ConnectionFailedEvent)(nil), "atomix.stores.raft.v1.ConnectionFailedEvent")
}

func init() { proto.RegisterFile("v1/raft.proto", fileDescriptor_078208a31684120b) }

var fileDescriptor_078208a31684120b = []byte{
	// 1720 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6f, 0x22, 0xc9,
	0x15, 0x77, 0x63, 0x30, 0xf0, 0x00, 0x1b, 0xca, 0xc6, 0xdb, 0x41, 0x1b, 0xe3, 0xed, 0x64, 0x15,
	0xbc, 0x3b, 0x8b, 0xd7, 0x8e, 0x12, 0x25, 0x97, 0x44, 0x03, 0xc6, 0xbb, 0x4e, 0xfc, 0x11, 0x35,
	0x9e, 0x9d, 0x48, 0x59, 0x0d, 0x2a, 0xd3, 0x05, 0xf4, 0x86, 0xee, 0x22, 0xdd, 0x05, 0x72, 0x56,
	0x89, 0xf2, 0x21, 0xe5, 0x1a, 0xed, 0x31, 0xa7, 0x1c, 0x26, 0x1f, 0x87, 0xfc, 0x17, 0xb9, 0xcd,
	0x71, 0x8e, 0x39, 0x91, 0xc8, 0xf3, 0x07, 0xe4, 0xee, 0xd3, 0xaa, 0xab, 0xab, 0x3f, 0x0c, 0xb4,
	0xcd, 0xd8, 0x96, 0x67, 0x6e, 0x74, 0xbd, 0xf7, 0x7e, 0xef, 0x57, 0xaf, 0x5e, 0xd5, 0x7b, 0x3c,
	0xc8, 0x8d, 0x76, 0xb6, 0x2d, 0xdc, 0x61, 0xd5, 0x81, 0x45, 0x19, 0x45, 0x45, 0xcc, 0xa8, 0xa1,
	0x9f, 0x57, 0x6d, 0x46, 0x2d, 0x62, 0x57, 0xb9, 0x64, 0xb4, 0x53, 0x2a, 0x77, 0x29, 0xed, 0xf6,
	0xc9, 0x36, 0x57, 0x3a, 0x1b, 0x76, 0xb6, 0x99, 0x6e, 0x10, 0x9b, 0x61, 0x63, 0xe0, 0xda, 0x95,
	0xd6, 0xba, 0xb4, 0x4b, 0xf9, 0xcf, 0x6d, 0xe7, 0x97, 0xbb, 0xaa, 0x3c, 0x97, 0x20, 0xd3, 0xec,
	0x61, 0x4b, 0xab, 0x53, 0xb3, 0xa3, 0x77, 0xd1, 0x0e, 0xa4, 0x6c, 0xe7, 0xb3, 0xa5, 0x6b, 0xb2,
	0xb4, 0x29, 0x55, 0x72, 0xb5, 0xf5, 0x8b, 0x71, 0x39, 0xc9, 0x55, 0x0e, 0xf6, 0x2e, 0x83, 0x9f,
	0x6a, 0x92, 0xeb, 0x1d, 0x68, 0x68, 0x1f, 0x52, 0x16, 0x19, 0xf4, 0xf5, 0x36, 0xb6, 0xe5, 0xd8,
	0xe6, 0x62, 0x25, 0xb3, 0xfb, 0xed, 0xea, 0x4c, 0x8e, 0x55, 0xd5, 0x55, 0x73, 0x5d, 0xd5, 0xe2,
	0x2f, 0xc6, 0xe5, 0x05, 0xd5, 0xb7, 0x45, 0x32, 0x24, 0x47, 0xc4, 0xb2, 0x75, 0x6a, 0xca, 0x8b,
	0x9b, 0x52, 0x25, 0xae, 0x7a, 0x9f, 0xca, 0xbf, 0x24, 0xc8, 0x5d, 0xb1, 0x45, 0x3f, 0x04, 0x10,
	0x76, 0x01, 0xd1, 0xd2, 0xc5, 0xb8, 0x9c, 0x16, 0x6a, 0x9c, 0x6a, 0xf0, 0xa1, 0xa6, 0x85, 0xf6,
	0x81, 0x86, 0x10, 0xc4, 0x7b, 0xd4, 0x66, 0x72, 0x6c, 0x53, 0xaa, 0xa4, 0x55, 0xfe, 0xdb, 0x59,
	0x1b, 0x50, 0x8b, 0x71, 0xbf, 0x09, 0x95, 0xff, 0x46, 0xdf, 0x87, 0xb8, 0x45, 0xfb, 0x44, 0x8e,
	0x6f, 0x4a, 0x95, 0xe5, 0x5d, 0xe5, 0xfa, 0x2d, 0xa9, 0xb4, 0x4f, 0x54, 0xae, 0xaf, 0xfc, 0x3f,
	0x06, 0xa0, 0xe2, 0x0e, 0x13, 0x4c, 0x77, 0x21, 0x4b, 0xfa, 0xa4, 0xcd, 0x74, 0x6a, 0xb6, 0x2c,
	0xc6, 0x38, 0xd7, 0x78, 0x6d, 0xe5, 0x62, 0x5c, 0xce, 0x34, 0xc4, 0xba, 0x7a, 0x7a, 0xaa, 0x66,
	0x3c, 0x25, 0x95, 0x31, 0xf4, 0x3d, 0xc8, 0xf5, 0x08, 0xb6, 0xd8, 0x19, 0xc1, 0x8c, 0x1b, 0xc5,
	0xb8, 0x51, 0xfe, 0x62, 0x5c, 0xce, 0x7e, 0xea, 0x09, 0x1c, 0xab, 0xac, 0xaf, 0xe6, 0x98, 0x6d,
	0x41, 0xde, 0x36, 0xf1, 0xc0, 0xee, 0x51, 0xd6, 0x22, 0x26, 0xb3, 0x74, 0x62, 0x8b, 0x48, 0xae,
	0x78, 0xeb, 0x0d, 0x77, 0x19, 0x6d, 0xc3, 0x6a, 0x9b, 0x1a, 0x03, 0xec, 0xf2, 0xa2, 0x23, 0x62,
	0xf5, 0x08, 0xd6, 0xf8, 0x5e, 0xe3, 0x2a, 0x0a, 0x44, 0x27, 0x42, 0x82, 0x1e, 0xc1, 0xaa, 0x81,
	0xcf, 0x5b, 0xba, 0xd9, 0x32, 0x88, 0xd1, 0xea, 0xd3, 0x6e, 0xcb, 0xd6, 0xbf, 0x24, 0x72, 0xc2,
	0x85, 0x37, 0xf0, 0xf9, 0x81, 0x79, 0x44, 0x8c, 0x43, 0xda, 0x6d, 0xea, 0x5f, 0x12, 0xf4, 0x03,
	0x90, 0x35, 0xdd, 0xc6, 0x67, 0x7d, 0xd2, 0xc2, 0x43, 0x46, 0x5b, 0x01, 0xa0, 0x2d, 0x2f, 0x6d,
	0x4a, 0x95, 0x94, 0xba, 0x2e, 0xe4, 0x8f, 0x87, 0x8c, 0xd6, 0x03, 0x29, 0xda, 0x85, 0x22, 0xb5,
	0x34, 0x62, 0x11, 0xad, 0xd5, 0xe6, 0x01, 0x6c, 0xb5, 0x7b, 0xd8, 0xec, 0x12, 0x39, 0xc9, 0xcd,
	0x56, 0x85, 0xd0, 0x0d, 0x6e, 0x9d, 0x8b, 0x14, 0x06, 0x59, 0x27, 0xe0, 0x3f, 0xb3, 0xe8, 0x80,
	0xda, 0xb8, 0x8f, 0xde, 0x85, 0x38, 0x23, 0x96, 0x21, 0x42, 0x9d, 0xba, 0x1c, 0x97, 0xe3, 0xa7,
	0xc4, 0x32, 0x54, 0xbe, 0xea, 0x1c, 0x88, 0x4d, 0x7e, 0x35, 0x24, 0x66, 0x9b, 0xb4, 0xcc, 0xa1,
	0x21, 0x62, 0xbb, 0x72, 0x39, 0x2e, 0x67, 0x9a, 0x62, 0xfd, 0x78, 0x68, 0xa8, 0x19, 0x3b, 0xf8,
	0x70, 0xf2, 0x43, 0xc3, 0x0c, 0xf3, 0x68, 0x66, 0x55, 0xfe, 0x5b, 0x69, 0x40, 0xfe, 0x13, 0x22,
	0x4e, 0x59, 0x75, 0x74, 0x6d, 0x76, 0x8b, 0xdb, 0xa3, 0x34, 0xa1, 0x10, 0x82, 0xb1, 0x07, 0xd4,
	0xb4, 0x09, 0xfa, 0x11, 0x24, 0xb8, 0x9c, 0x83, 0x64, 0x22, 0x93, 0x2f, 0x74, 0x71, 0xc5, 0x6d,
	0x72, 0xcd, 0x94, 0x3f, 0xc7, 0xa0, 0x58, 0xa3, 0x94, 0xd9, 0xcc, 0xc2, 0x03, 0xae, 0x75, 0x7b,
	0x86, 0x13, 0x77, 0x2d, 0xf6, 0x3a, 0x77, 0x2d, 0xfc, 0x34, 0x2c, 0xde, 0xe1, 0x69, 0xf8, 0x31,
	0x2c, 0xb9, 0xd9, 0xc0, 0x33, 0x34, 0xb3, 0xfb, 0x5e, 0x14, 0x8a, 0x7f, 0xef, 0x04, 0x84, 0x30,
	0x53, 0x64, 0x58, 0x9f, 0x8c, 0x87, 0x1b, 0x6a, 0xe5, 0x9f, 0x12, 0x14, 0x1e, 0x6b, 0x9a, 0x77,
	0x8f, 0x6f, 0x1f, 0xa6, 0x3d, 0x48, 0x0a, 0xbe, 0x3c, 0x46, 0xaf, 0xb7, 0x55, 0xcf, 0xf4, 0x9a,
	0x47, 0x70, 0x0d, 0x50, 0x98, 0xa7, 0xa0, 0xff, 0x57, 0x09, 0xd6, 0x54, 0x62, 0xd0, 0x11, 0xb9,
	0xfb, 0x0e, 0xee, 0x70, 0xd0, 0xd1, 0xb4, 0xdf, 0x81, 0xe2, 0x04, 0x3f, 0xc1, 0xfc, 0xdf, 0x12,
	0xe4, 0x7f, 0x42, 0x75, 0xf3, 0x0d, 0xa6, 0x67, 0x90, 0x56, 0x8b, 0xb7, 0x4b, 0xab, 0x55, 0x28,
	0x84, 0xb6, 0x20, 0x36, 0xb6, 0x0f, 0x85, 0x43, 0x82, 0x47, 0xe4, 0x8e, 0x1b, 0x73, 0x0e, 0x3c,
	0x8c, 0x23, 0xd0, 0xff, 0x20, 0x41, 0x61, 0x8f, 0xf4, 0x09, 0x23, 0x7b, 0x98, 0xbd, 0x99, 0xd3,
	0x76, 0x98, 0x85, 0x29, 0x08, 0x66, 0xcb, 0x90, 0x7d, 0x8a, 0x59, 0xbb, 0x27, 0x38, 0x29, 0x7f,
	0xca, 0x40, 0xa2, 0x31, 0x22, 0x26, 0x43, 0x35, 0x48, 0xfb, 0xdd, 0x88, 0x78, 0xd2, 0x4a, 0x55,
	0xb7, 0x5f, 0xa9, 0x7a, 0xfd, 0x4a, 0xf5, 0xd4, 0xd3, 0xa8, 0xa5, 0x9c, 0x18, 0x7f, 0xf5, 0xdf,
	0xb2, 0xa4, 0x06, 0x66, 0xe8, 0x04, 0x72, 0x1e, 0x5d, 0x8b, 0x60, 0xed, 0xd7, 0xe2, 0x92, 0x55,
	0x6e, 0xa8, 0xcb, 0x8e, 0x2a, 0x27, 0xf1, 0xe9, 0x82, 0x9a, 0xb5, 0x42, 0x8b, 0x48, 0x85, 0xe5,
	0x3e, 0xc1, 0x1a, 0xb1, 0x5a, 0xc3, 0x81, 0x86, 0x19, 0xd1, 0x44, 0x12, 0x6c, 0x45, 0x20, 0x1e,
	0x72, 0xe5, 0x27, 0xae, 0xae, 0x07, 0x99, 0xeb, 0x87, 0x57, 0x51, 0x17, 0x8a, 0x6e, 0x66, 0x0c,
	0x2d, 0xcc, 0x2b, 0xab, 0x5b, 0xbc, 0x34, 0xf1, 0x6c, 0x7d, 0x1c, 0x01, 0x5d, 0x0f, 0xdb, 0xb8,
	0x45, 0xcd, 0xf7, 0xb0, 0xd6, 0x9e, 0x21, 0x44, 0x04, 0x8a, 0x36, 0x31, 0xb5, 0x96, 0x5f, 0xef,
	0x6d, 0x86, 0x2d, 0x67, 0x0f, 0x09, 0xee, 0x68, 0x3b, 0xaa, 0x60, 0x10, 0x53, 0x6b, 0x0a, 0x93,
	0xa6, 0x6b, 0xe1, 0xf9, 0x59, 0xb5, 0xa7, 0x65, 0xe8, 0x97, 0xf0, 0xce, 0x55, 0x37, 0x4e, 0x21,
	0x77, 0x0e, 0x5e, 0xe3, 0x65, 0x3c, 0xb3, 0xbb, 0x33, 0x87, 0xa3, 0xba, 0x67, 0xe3, 0xb9, 0x2a,
	0xda, 0xb3, 0xa4, 0xd3, 0x7b, 0xc2, 0x67, 0x94, 0xef, 0x29, 0x39, 0xf7, 0x9e, 0x1e, 0xbb, 0x16,
	0x33, 0xf7, 0x24, 0x64, 0xe8, 0x17, 0x50, 0xf0, 0x3d, 0x58, 0xa4, 0x4d, 0xf4, 0x11, 0xd1, 0xe4,
	0x14, 0x77, 0xf1, 0x28, 0xca, 0x85, 0xd0, 0x57, 0x85, 0xba, 0x87, 0xef, 0xb7, 0x5b, 0x9e, 0x00,
	0x3d, 0x03, 0x14, 0x06, 0x77, 0x1a, 0x2b, 0xa2, 0xc9, 0x69, 0x8e, 0xfe, 0xd1, 0xcd, 0xe8, 0xae,
	0xbe, 0x07, 0x5f, 0xb0, 0x27, 0x25, 0xe8, 0xe7, 0xa1, 0x16, 0xaf, 0x6d, 0x11, 0x9e, 0xb6, 0xc0,
	0xd1, 0x3f, 0xbc, 0x01, 0xbd, 0xee, 0x6a, 0x7b, 0xd8, 0x7e, 0x47, 0x28, 0xd6, 0xaf, 0x30, 0x17,
	0xed, 0x1a, 0xd1, 0xe4, 0xcc, 0x5c, 0xcc, 0xeb, 0x9e, 0xfe, 0x14, 0x73, 0x5f, 0xe2, 0xdc, 0x5f,
	0xa7, 0x6b, 0x0c, 0xa0, 0xb3, 0xd7, 0xde, 0xdf, 0x43, 0xda, 0x9d, 0x42, 0xcd, 0xf6, 0x43, 0x8b,
	0xe8, 0x09, 0xac, 0xf4, 0x69, 0x57, 0x3b, 0x0b, 0x41, 0xe6, 0x38, 0xe4, 0x07, 0xd1, 0x90, 0x7b,
	0xb5, 0x29, 0xd0, 0x65, 0x0e, 0x12, 0xc0, 0x7e, 0x01, 0xeb, 0x6d, 0x6a, 0x9a, 0xa2, 0x63, 0x77,
	0x1e, 0x9f, 0xb3, 0xbe, 0x6e, 0xf7, 0x88, 0x26, 0x2f, 0x5f, 0x9b, 0xf1, 0x75, 0xdf, 0xa8, 0x11,
	0xd8, 0xf8, 0x19, 0xdf, 0x9e, 0x25, 0x75, 0x52, 0x31, 0xe4, 0xab, 0x83, 0xf5, 0x3e, 0xd1, 0xe4,
	0x95, 0x6b, 0x53, 0x31, 0x70, 0xb3, 0xcf, 0xd5, 0xfd, 0x54, 0x6c, 0x4f, 0x08, 0x6a, 0x49, 0x48,
	0x10, 0x47, 0xa8, 0xec, 0xc3, 0x72, 0x60, 0x75, 0x60, 0x76, 0xa8, 0x53, 0xad, 0xb1, 0xa6, 0x59,
	0xc4, 0xb6, 0xf9, 0x6b, 0x9c, 0x56, 0xbd, 0x4f, 0x54, 0x82, 0x94, 0x77, 0x74, 0xfc, 0x81, 0x4d,
	0xa9, 0xfe, 0xb7, 0xf2, 0x1b, 0xc8, 0x8a, 0x57, 0xd5, 0x7d, 0xd5, 0xef, 0xa5, 0xe6, 0xc4, 0xe7,
	0xad, 0x39, 0x9f, 0x43, 0x61, 0xea, 0x4d, 0x47, 0x9f, 0x04, 0x3d, 0x97, 0x5b, 0x56, 0xbe, 0x75,
	0x7d, 0x39, 0xe0, 0x56, 0x6e, 0x7d, 0x79, 0x39, 0x2e, 0x4b, 0x7e, 0xdb, 0xa5, 0x68, 0xf0, 0x8d,
	0xc8, 0x47, 0xf8, 0xfe, 0xbc, 0x3c, 0x97, 0x78, 0x49, 0x9f, 0x28, 0x23, 0xf7, 0x86, 0xef, 0xff,
	0xf1, 0x89, 0xcd, 0xfc, 0xe3, 0xf3, 0x3e, 0x2c, 0xb9, 0xd5, 0xca, 0x6d, 0xd1, 0x6a, 0xb9, 0xab,
	0xb1, 0x16, 0x42, 0xe5, 0x6f, 0x12, 0xc8, 0x51, 0x75, 0xe2, 0xfe, 0xa8, 0x96, 0x21, 0xa1, 0x9b,
	0x1a, 0x39, 0x17, 0x5c, 0xd3, 0x97, 0xe3, 0x72, 0xe2, 0xc0, 0x59, 0x50, 0xdd, 0x75, 0xf4, 0x4d,
	0x88, 0x31, 0x3a, 0x9b, 0x69, 0x8c, 0x51, 0xe5, 0x1f, 0x12, 0x94, 0xa2, 0x8b, 0xcc, 0xdb, 0xc3,
	0x73, 0x32, 0x9a, 0xe1, 0x0a, 0xf5, 0xf6, 0xb0, 0xfc, 0xbb, 0x04, 0xc5, 0x99, 0x45, 0xee, 0x01,
	0x29, 0xbe, 0x07, 0xf1, 0x8e, 0x45, 0x8d, 0xd9, 0x24, 0xb9, 0x48, 0xf9, 0xa3, 0x04, 0xeb, 0xb3,
	0xab, 0xe5, 0xc3, 0xf1, 0x54, 0x7e, 0x2f, 0xc1, 0xda, 0xac, 0xa2, 0xfa, 0x80, 0x14, 0xc2, 0x71,
	0xb8, 0x5a, 0xd0, 0x1e, 0x90, 0x04, 0x83, 0xd4, 0x21, 0xed, 0x3e, 0xb4, 0xd7, 0xdf, 0x42, 0x61,
	0xaa, 0x35, 0x78, 0x40, 0xf7, 0xbf, 0x83, 0xd5, 0x19, 0x6d, 0xc4, 0x03, 0x12, 0xc0, 0x50, 0x8a,
	0xee, 0x34, 0x50, 0x1d, 0xe2, 0xba, 0xd9, 0xa1, 0x82, 0xc4, 0xfb, 0x37, 0xf6, 0x10, 0x4e, 0x37,
	0x10, 0xa2, 0xc1, 0x8d, 0x95, 0xcf, 0xa1, 0x38, 0xb3, 0xcb, 0xb8, 0x17, 0xf4, 0x0f, 0x8e, 0x21,
	0x13, 0x9a, 0x99, 0xa2, 0x0c, 0x24, 0x9f, 0x1c, 0xff, 0xf4, 0xf8, 0xe4, 0xe9, 0x71, 0x7e, 0x01,
	0x01, 0x2c, 0x1d, 0x35, 0x8e, 0x6a, 0x0d, 0x35, 0x2f, 0xa1, 0x2c, 0xa4, 0x4e, 0x6a, 0xcd, 0x86,
	0xfa, 0x59, 0x43, 0xcd, 0xc7, 0x1c, 0xb5, 0xa7, 0x07, 0xa7, 0xc7, 0x8d, 0x66, 0x33, 0xbf, 0xe8,
	0x7c, 0xa8, 0x8d, 0xa3, 0x93, 0xcf, 0x1a, 0x7b, 0xf9, 0xf8, 0xee, 0x5f, 0x96, 0x20, 0x7e, 0x4c,
	0x35, 0x82, 0x9e, 0x41, 0xda, 0x1f, 0xa4, 0xa1, 0xef, 0x44, 0x90, 0x9b, 0x9c, 0xd8, 0x95, 0x2a,
	0x37, 0x2b, 0x8a, 0x99, 0x9c, 0x01, 0xcb, 0x57, 0x47, 0x48, 0x28, 0xaa, 0x47, 0x9b, 0x39, 0x79,
	0x2b, 0x7d, 0x34, 0xa7, 0xb6, 0x70, 0x87, 0x01, 0x82, 0x71, 0x0f, 0x8a, 0xa2, 0x39, 0x35, 0xb9,
	0x2a, 0x6d, 0xcd, 0xa1, 0x29, 0x5c, 0x7c, 0x01, 0xb9, 0x2b, 0xa3, 0x19, 0xf4, 0x61, 0x64, 0xd6,
	0x4e, 0x0f, 0x98, 0x4a, 0x8f, 0xe6, 0x53, 0x16, 0xbe, 0x9e, 0x41, 0xda, 0x9f, 0x94, 0x44, 0x9e,
	0xce, 0xe4, 0x38, 0x28, 0xf2, 0x74, 0xa6, 0x86, 0x2e, 0x4e, 0xb8, 0x82, 0x61, 0x49, 0x64, 0xb8,
	0xa6, 0xe6, 0x32, 0xa5, 0xad, 0x39, 0x34, 0x03, 0x17, 0xc1, 0xd4, 0x23, 0xd2, 0xc5, 0xd4, 0x6c,
	0x26, 0xd2, 0xc5, 0xf4, 0x08, 0x05, 0x1d, 0x42, 0x82, 0x8f, 0x50, 0x50, 0xd4, 0xfb, 0x11, 0x1e,
	0xb0, 0x94, 0xde, 0x8d, 0x50, 0xe2, 0xb7, 0xf5, 0x63, 0xa9, 0x26, 0xbf, 0xb8, 0xd8, 0x90, 0x5e,
	0x5e, 0x6c, 0x48, 0xff, 0xbb, 0xd8, 0x90, 0xbe, 0x7a, 0xb5, 0xb1, 0xf0, 0xf2, 0xd5, 0xc6, 0xc2,
	0x7f, 0x5e, 0x6d, 0x2c, 0x9c, 0x2d, 0xf1, 0xa9, 0xcb, 0x77, 0xbf, 0x0e, 0x00, 0x00, 0xff, 0xff,
	0x9d, 0xb3, 0x90, 0xef, 0x5b, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NodeClient interface {
	GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*GetConfigResponse, error)
	BootstrapShard(ctx context.Context, in *BootstrapShardRequest, opts ...grpc.CallOption) (*BootstrapShardResponse, error)
	AddReplica(ctx context.Context, in *AddReplicaRequest, opts ...grpc.CallOption) (*AddReplicaResponse, error)
	RemoveReplica(ctx context.Context, in *RemoveReplicaRequest, opts ...grpc.CallOption) (*RemoveReplicaResponse, error)
	JoinShard(ctx context.Context, in *JoinShardRequest, opts ...grpc.CallOption) (*JoinShardResponse, error)
	LeaveShard(ctx context.Context, in *LeaveShardRequest, opts ...grpc.CallOption) (*LeaveShardResponse, error)
	DeleteData(ctx context.Context, in *DeleteDataRequest, opts ...grpc.CallOption) (*DeleteDataResponse, error)
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Node_WatchClient, error)
}

type nodeClient struct {
	cc *grpc.ClientConn
}

func NewNodeClient(cc *grpc.ClientConn) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*GetConfigResponse, error) {
	out := new(GetConfigResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/GetConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) BootstrapShard(ctx context.Context, in *BootstrapShardRequest, opts ...grpc.CallOption) (*BootstrapShardResponse, error) {
	out := new(BootstrapShardResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/BootstrapShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) AddReplica(ctx context.Context, in *AddReplicaRequest, opts ...grpc.CallOption) (*AddReplicaResponse, error) {
	out := new(AddReplicaResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/AddReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) RemoveReplica(ctx context.Context, in *RemoveReplicaRequest, opts ...grpc.CallOption) (*RemoveReplicaResponse, error) {
	out := new(RemoveReplicaResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/RemoveReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) JoinShard(ctx context.Context, in *JoinShardRequest, opts ...grpc.CallOption) (*JoinShardResponse, error) {
	out := new(JoinShardResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/JoinShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) LeaveShard(ctx context.Context, in *LeaveShardRequest, opts ...grpc.CallOption) (*LeaveShardResponse, error) {
	out := new(LeaveShardResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/LeaveShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) DeleteData(ctx context.Context, in *DeleteDataRequest, opts ...grpc.CallOption) (*DeleteDataResponse, error) {
	out := new(DeleteDataResponse)
	err := c.cc.Invoke(ctx, "/atomix.stores.raft.v1.Node/DeleteData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Node_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Node_serviceDesc.Streams[0], "/atomix.stores.raft.v1.Node/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Node_WatchClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type nodeWatchClient struct {
	grpc.ClientStream
}

func (x *nodeWatchClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeServer is the server API for Node service.
type NodeServer interface {
	GetConfig(context.Context, *GetConfigRequest) (*GetConfigResponse, error)
	BootstrapShard(context.Context, *BootstrapShardRequest) (*BootstrapShardResponse, error)
	AddReplica(context.Context, *AddReplicaRequest) (*AddReplicaResponse, error)
	RemoveReplica(context.Context, *RemoveReplicaRequest) (*RemoveReplicaResponse, error)
	JoinShard(context.Context, *JoinShardRequest) (*JoinShardResponse, error)
	LeaveShard(context.Context, *LeaveShardRequest) (*LeaveShardResponse, error)
	DeleteData(context.Context, *DeleteDataRequest) (*DeleteDataResponse, error)
	Watch(*WatchRequest, Node_WatchServer) error
}

// UnimplementedNodeServer can be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (*UnimplementedNodeServer) GetConfig(ctx context.Context, req *GetConfigRequest) (*GetConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (*UnimplementedNodeServer) BootstrapShard(ctx context.Context, req *BootstrapShardRequest) (*BootstrapShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BootstrapShard not implemented")
}
func (*UnimplementedNodeServer) AddReplica(ctx context.Context, req *AddReplicaRequest) (*AddReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReplica not implemented")
}
func (*UnimplementedNodeServer) RemoveReplica(ctx context.Context, req *RemoveReplicaRequest) (*RemoveReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveReplica not implemented")
}
func (*UnimplementedNodeServer) JoinShard(ctx context.Context, req *JoinShardRequest) (*JoinShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinShard not implemented")
}
func (*UnimplementedNodeServer) LeaveShard(ctx context.Context, req *LeaveShardRequest) (*LeaveShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveShard not implemented")
}
func (*UnimplementedNodeServer) DeleteData(ctx context.Context, req *DeleteDataRequest) (*DeleteDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteData not implemented")
}
func (*UnimplementedNodeServer) Watch(req *WatchRequest, srv Node_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}

func RegisterNodeServer(s *grpc.Server, srv NodeServer) {
	s.RegisterService(&_Node_serviceDesc, srv)
}

func _Node_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetConfig(ctx, req.(*GetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_BootstrapShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BootstrapShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).BootstrapShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/BootstrapShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).BootstrapShard(ctx, req.(*BootstrapShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_AddReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).AddReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/AddReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).AddReplica(ctx, req.(*AddReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_RemoveReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).RemoveReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/RemoveReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).RemoveReplica(ctx, req.(*RemoveReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_JoinShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).JoinShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/JoinShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).JoinShard(ctx, req.(*JoinShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_LeaveShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).LeaveShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/LeaveShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).LeaveShard(ctx, req.(*LeaveShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_DeleteData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).DeleteData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/atomix.stores.raft.v1.Node/DeleteData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).DeleteData(ctx, req.(*DeleteDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeServer).Watch(m, &nodeWatchServer{stream})
}

type Node_WatchServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type nodeWatchServer struct {
	grpc.ServerStream
}

func (x *nodeWatchServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _Node_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atomix.stores.raft.v1.Node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _Node_GetConfig_Handler,
		},
		{
			MethodName: "BootstrapShard",
			Handler:    _Node_BootstrapShard_Handler,
		},
		{
			MethodName: "AddReplica",
			Handler:    _Node_AddReplica_Handler,
		},
		{
			MethodName: "RemoveReplica",
			Handler:    _Node_RemoveReplica_Handler,
		},
		{
			MethodName: "JoinShard",
			Handler:    _Node_JoinShard_Handler,
		},
		{
			MethodName: "LeaveShard",
			Handler:    _Node_LeaveShard_Handler,
		},
		{
			MethodName: "DeleteData",
			Handler:    _Node_DeleteData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Node_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/raft.proto",
}

func (m *ShardConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Role != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x20
	}
	if m.Port != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderedConfigChange {
		i--
		if m.OrderedConfigChange {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DisableAutoCompactions {
		i--
		if m.DisableAutoCompactions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MaxInMemLogSize != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.MaxInMemLogSize))
		i--
		dAtA[i] = 0x28
	}
	if m.CompactionOverhead != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.CompactionOverhead))
		i--
		dAtA[i] = 0x20
	}
	if m.SnapshotEntries != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.SnapshotEntries))
		i--
		dAtA[i] = 0x18
	}
	if m.HeartbeatRTT != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.HeartbeatRTT))
		i--
		dAtA[i] = 0x10
	}
	if m.ElectionRTT != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ElectionRTT))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SequenceNum != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.SequenceNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BootstrapShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BootstrapShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BootstrapShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BootstrapShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BootstrapShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BootstrapShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AddReplicaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddReplicaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddReplicaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddReplicaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddReplicaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddReplicaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RemoveReplicaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveReplicaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveReplicaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.ReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveReplicaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveReplicaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveReplicaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *JoinShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JoinShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LeaveShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaveShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeaveShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaveShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DeleteDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *WatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintRaft(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Event_ReplicaReady) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_ReplicaReady) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReplicaReady != nil {
		{
			size, err := m.ReplicaReady.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Event_LeaderUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_LeaderUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaderUpdated != nil {
		{
			size, err := m.LeaderUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Event_ConfigurationChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_ConfigurationChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfigurationChanged != nil {
		{
			size, err := m.ConfigurationChanged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Event_SendSnapshotStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SendSnapshotStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SendSnapshotStarted != nil {
		{
			size, err := m.SendSnapshotStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Event_SendSnapshotCompleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SendSnapshotCompleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SendSnapshotCompleted != nil {
		{
			size, err := m.SendSnapshotCompleted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Event_SendSnapshotAborted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SendSnapshotAborted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SendSnapshotAborted != nil {
		{
			size, err := m.SendSnapshotAborted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Event_SnapshotReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SnapshotReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SnapshotReceived != nil {
		{
			size, err := m.SnapshotReceived.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Event_SnapshotRecovered) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SnapshotRecovered) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SnapshotRecovered != nil {
		{
			size, err := m.SnapshotRecovered.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Event_SnapshotCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SnapshotCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SnapshotCreated != nil {
		{
			size, err := m.SnapshotCreated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Event_SnapshotCompacted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_SnapshotCompacted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SnapshotCompacted != nil {
		{
			size, err := m.SnapshotCompacted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Event_LogCompacted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_LogCompacted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogCompacted != nil {
		{
			size, err := m.LogCompacted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Event_LogdbCompacted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_LogdbCompacted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LogdbCompacted != nil {
		{
			size, err := m.LogdbCompacted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Event_ConnectionEstablished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_ConnectionEstablished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectionEstablished != nil {
		{
			size, err := m.ConnectionEstablished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Event_ConnectionFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event_ConnectionFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConnectionFailed != nil {
		{
			size, err := m.ConnectionFailed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *ConnectionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Snapshot {
		i--
		if m.Snapshot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplicaID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ShardID != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaReadyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaReadyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaReadyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConfigurationChangedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigurationChangedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigurationChangedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LeaderUpdatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderUpdatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderUpdatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x18
	}
	if m.Term != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SendSnapshotStartedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSnapshotStartedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendSnapshotStartedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SendSnapshotCompletedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSnapshotCompletedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendSnapshotCompletedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SendSnapshotAbortedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSnapshotAbortedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendSnapshotAbortedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SnapshotReceivedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotReceivedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotReceivedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SnapshotRecoveredEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotRecoveredEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotRecoveredEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SnapshotCreatedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotCreatedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotCreatedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SnapshotCompactedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotCompactedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotCompactedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LogEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LogCompactedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogCompactedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogCompactedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LogDBCompactedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogDBCompactedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogDBCompactedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintRaft(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.ReplicaEvent.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConnectionEstablishedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionEstablishedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionEstablishedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ConnectionInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConnectionFailedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionFailedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionFailedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ConnectionInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaft(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ShardConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovRaft(uint64(m.Version))
	}
	return n
}

func (m *ReplicaConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ReplicaID))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovRaft(uint64(m.Port))
	}
	if m.Role != 0 {
		n += 1 + sovRaft(uint64(m.Role))
	}
	return n
}

func (m *RaftConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElectionRTT != 0 {
		n += 1 + sovRaft(uint64(m.ElectionRTT))
	}
	if m.HeartbeatRTT != 0 {
		n += 1 + sovRaft(uint64(m.HeartbeatRTT))
	}
	if m.SnapshotEntries != 0 {
		n += 1 + sovRaft(uint64(m.SnapshotEntries))
	}
	if m.CompactionOverhead != 0 {
		n += 1 + sovRaft(uint64(m.CompactionOverhead))
	}
	if m.MaxInMemLogSize != 0 {
		n += 1 + sovRaft(uint64(m.MaxInMemLogSize))
	}
	if m.DisableAutoCompactions {
		n += 2
	}
	if m.OrderedConfigChange {
		n += 2
	}
	return n
}

func (m *RaftProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.SequenceNum != 0 {
		n += 1 + sovRaft(uint64(m.SequenceNum))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *GetConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	return n
}

func (m *GetConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *BootstrapShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ReplicaID))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	l = m.Config.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *BootstrapShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AddReplicaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	l = m.Replica.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Version != 0 {
		n += 1 + sovRaft(uint64(m.Version))
	}
	return n
}

func (m *AddReplicaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RemoveReplicaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ReplicaID))
	}
	if m.Version != 0 {
		n += 1 + sovRaft(uint64(m.Version))
	}
	return n
}

func (m *RemoveReplicaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *JoinShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ReplicaID))
	}
	l = m.Config.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *JoinShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LeaveShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	return n
}

func (m *LeaveShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DeleteDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ReplicaID))
	}
	return n
}

func (m *DeleteDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *WatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovRaft(uint64(l))
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *Event_ReplicaReady) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaReady != nil {
		l = m.ReplicaReady.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_LeaderUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaderUpdated != nil {
		l = m.LeaderUpdated.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_ConfigurationChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigurationChanged != nil {
		l = m.ConfigurationChanged.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SendSnapshotStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendSnapshotStarted != nil {
		l = m.SendSnapshotStarted.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SendSnapshotCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendSnapshotCompleted != nil {
		l = m.SendSnapshotCompleted.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SendSnapshotAborted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendSnapshotAborted != nil {
		l = m.SendSnapshotAborted.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SnapshotReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotReceived != nil {
		l = m.SnapshotReceived.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SnapshotRecovered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotRecovered != nil {
		l = m.SnapshotRecovered.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SnapshotCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotCreated != nil {
		l = m.SnapshotCreated.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_SnapshotCompacted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapshotCompacted != nil {
		l = m.SnapshotCompacted.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_LogCompacted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogCompacted != nil {
		l = m.LogCompacted.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_LogdbCompacted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogdbCompacted != nil {
		l = m.LogdbCompacted.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_ConnectionEstablished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionEstablished != nil {
		l = m.ConnectionEstablished.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *Event_ConnectionFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionFailed != nil {
		l = m.ConnectionFailed.Size()
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}
func (m *ConnectionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.Snapshot {
		n += 2
	}
	return n
}

func (m *ReplicaEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRaft(uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRaft(uint64(m.ReplicaID))
	}
	return n
}

func (m *ReplicaReadyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *ConfigurationChangedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *LeaderUpdatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Term != 0 {
		n += 1 + sovRaft(uint64(m.Term))
	}
	if m.Leader != 0 {
		n += 1 + sovRaft(uint64(m.Leader))
	}
	return n
}

func (m *SendSnapshotStartedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	return n
}

func (m *SendSnapshotCompletedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	return n
}

func (m *SendSnapshotAbortedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	if m.To != 0 {
		n += 1 + sovRaft(uint64(m.To))
	}
	return n
}

func (m *SnapshotReceivedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	if m.From != 0 {
		n += 1 + sovRaft(uint64(m.From))
	}
	return n
}

func (m *SnapshotRecoveredEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	return n
}

func (m *SnapshotCreatedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	return n
}

func (m *SnapshotCompactedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	return n
}

func (m *LogEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	return n
}

func (m *LogCompactedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	return n
}

func (m *LogDBCompactedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ReplicaEvent.Size()
	n += 1 + l + sovRaft(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaft(uint64(m.Index))
	}
	return n
}

func (m *ConnectionEstablishedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ConnectionInfo.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func (m *ConnectionFailedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ConnectionInfo.Size()
	n += 1 + l + sovRaft(uint64(l))
	return n
}

func sovRaft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShardConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, ReplicaConfig{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ReplicaRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRTT", wireType)
			}
			m.ElectionRTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectionRTT |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatRTT", wireType)
			}
			m.HeartbeatRTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatRTT |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotEntries", wireType)
			}
			m.SnapshotEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotEntries |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionOverhead", wireType)
			}
			m.CompactionOverhead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionOverhead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInMemLogSize", wireType)
			}
			m.MaxInMemLogSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInMemLogSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAutoCompactions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableAutoCompactions = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderedConfigChange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderedConfigChange = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= Term(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNum", wireType)
			}
			m.SequenceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNum |= SequenceNum(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BootstrapShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BootstrapShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BootstrapShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, ReplicaConfig{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BootstrapShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BootstrapShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BootstrapShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddReplicaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddReplicaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddReplicaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddReplicaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddReplicaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddReplicaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveReplicaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveReplicaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveReplicaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveReplicaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveReplicaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveReplicaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaveShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaveShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaveShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaveShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaReady", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplicaReadyEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_ReplicaReady{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LeaderUpdatedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_LeaderUpdated{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationChanged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigurationChangedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_ConfigurationChanged{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendSnapshotStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SendSnapshotStartedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SendSnapshotStarted{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendSnapshotCompleted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SendSnapshotCompletedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SendSnapshotCompleted{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendSnapshotAborted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SendSnapshotAbortedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SendSnapshotAborted{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotReceived", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SnapshotReceivedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SnapshotReceived{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotRecovered", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SnapshotRecoveredEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SnapshotRecovered{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotCreated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SnapshotCreatedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SnapshotCreated{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotCompacted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SnapshotCompactedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_SnapshotCompacted{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogCompacted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogCompactedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_LogCompacted{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogdbCompacted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogDBCompactedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_LogdbCompacted{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionEstablished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConnectionEstablishedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_ConnectionEstablished{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConnectionFailedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &Event_ConnectionFailed{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshot = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= ShardID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaReadyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaReadyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaReadyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigurationChangedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigurationChangedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigurationChangedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderUpdatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderUpdatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderUpdatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= Term(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSnapshotStartedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSnapshotStartedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSnapshotStartedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSnapshotCompletedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSnapshotCompletedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSnapshotCompletedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSnapshotAbortedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSnapshotAbortedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSnapshotAbortedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotReceivedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotReceivedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotReceivedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= ReplicaID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotRecoveredEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotRecoveredEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotRecoveredEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotCreatedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotCreatedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotCreatedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotCompactedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotCompactedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotCompactedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogCompactedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogCompactedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogCompactedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogDBCompactedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogDBCompactedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogDBCompactedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicaEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionEstablishedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionEstablishedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionEstablishedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConnectionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionFailedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionFailedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionFailedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConnectionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaft = fmt.Errorf("proto: unexpected end of group")
)
